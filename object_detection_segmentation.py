# -*- coding: utf-8 -*-
"""TestStreamlit_Version_06_05_py.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mp5gYtlD6O_j7Vku_Qp3rWgXIVfumcTi
"""

pip install pixellib

pip install streamlit

pip install pyngrok

pip install pafy

pip install youtube_dl


%%writefile app.py
import streamlit as st
import numpy as np
import pandas as pd
import pixellib
from pixellib.instance import instance_segmentation
import cv2
from google.colab.patches import cv2_imshow
import networkx as nx
import matplotlib.pyplot as plt
import pafy
 
 

def printGraph(triples):
 
    G = nx.MultiDiGraph()
    for triple in triples:
        print(triple[0])
        G.add_nodes_from([triple[0],triple[2]])
        G.add_edge(triple[0], triple[2])
         
    pos = nx.shell_layout(G)
    plt.figure()
    nx.draw(G, pos, edge_color='black', width=1, linewidths=1,
            node_size=500, node_color='seagreen', alpha=0.9,
            labels={node: node for node in G.nodes()})
    for triple in triples:
        nx.draw_networkx_edge_labels(G, pos, edge_labels={(triple[0], triple[2]):triple[1]},font_color='k')
     
    plt.axis('off')
    plt.savefig("Graph.png", format="PNG")
    plt.show()


 
instance_seg = instance_segmentation(infer_speed = "fast")
instance_seg.load_model("mask_rcnn_coco.h5")
 

url = "https://www.youtube.com/watch?v=LV8viSdfNl0"
video = pafy.new(url)
best = video.getbest(preftype="mp4")
 

capture = cv2.VideoCapture(best.url) 
size = (
    int(capture.get(cv2.CAP_PROP_FRAME_WIDTH)),
    int(capture.get(cv2.CAP_PROP_FRAME_HEIGHT))
)
codec = cv2.VideoWriter_fourcc(*'DIVX')
output = cv2.VideoWriter('videofile_masked.mp4', codec, 10.0, size)

 
 
titre = st.empty()
image1 = st.empty()
image2 = st.empty()
graph = st.empty()
 
 
 
i=0
frame_rate_divider=20
while(capture.isOpened()):
    ret, frame = capture.read()
    if ret:
        # add mask to frame
        output.write(frame)
        cv2_imshow(frame)

        if i%(frame_rate_divider/2) == 0:
          cv2.imwrite("frameimg.jpg", frame)

        if i%frame_rate_divider == 0:

            image="frameimg.jpg"

            segmask, output2 = instance_seg.segmentImage(image, show_bboxes= True)
            cv2.imwrite("frameimgwithboxes.jpg", output2)
            cv2_imshow(output2)
 
            #print("Regions of Interest (ROIs)")
            #print(segmask['rois'])

            entity_pairs=[]
            noOfEntities=len(segmask['class_ids'])
            #print("Number of entities:")
            #print(noOfEntities)

            class_names = ['BG', 'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light', 'fire hydrant', 'stop sign',
                          'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella',
                          'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard',
                          'surfboard', 'tennis racket', 'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange',
                          'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
                          'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors',
                          'teddy bear', 'hair drier', 'toothbrush']
 
            class_number = [0,0,0,0,0,0,0,0,0,0,
                          0,0,0,0,0,0,0,0,0,0,
                          0,0,0,0,0,0,0,0,0,0,
                          0,0,0,0,0,0,0,0,0,0,
                          0,0,0,0,0,0,0,0,0,0,
                          0,0,0,0,0,0,0,0,0,0,
                          0,0,0,0,0,0,0,0,0,0,
                          0,0,0,0,0,0,0,0,0,0,0]
 
            relations=[]
            entity_number = [0] * noOfEntities
            position=0
            #Position=0, nothing happen
            #Position=1, the object is in front or behind another

            for i in range(noOfEntities):
                class_number[segmask['class_ids'][i]] += 1;
                entity_number[i] = class_number[segmask['class_ids'][i]];
                print("passage num " + str(i))

            for i in range(noOfEntities):
                for j in range(noOfEntities):
                    position=0
                    if i!=j:
                        #Down right corner overlaps
                        if(segmask['rois'][i][2] > segmask['rois'][j][0] and segmask['rois'][i][2] < segmask['rois'][j][2]
                          and segmask['rois'][i][3] > segmask['rois'][j][1] and segmask['rois'][i][3] < segmask['rois'][j][3]):
                            if(segmask['rois'][i][2] < segmask['rois'][j][0]+((segmask['rois'][j][2]-segmask['rois'][j][0])/2)):
                                # _________
                                #|////|    |
                                #|----|----|
                                #|____|____|
                                if(segmask['rois'][i][3] < segmask['rois'][j][1]+((segmask['rois'][j][3]-segmask['rois'][j][1])/2)):
                                    entity_pairs.append([class_names[segmask['class_ids'][i]]+str(entity_number[i]), class_names[segmask['class_ids'][j]]+str(entity_number[j])])
                                    relations.append("is above left to")
                                # _________
                                #|/////////|
                                #|---------|
                                #|_________|
                                else:
                                    entity_pairs.append([class_names[segmask['class_ids'][i]]+str(entity_number[i]), class_names[segmask['class_ids'][j]]+str(entity_number[j])])
                                    relations.append("is above")
                            else:
                                # _________
                                #|////|    |
                                #|////|----|
                                #|////|____|
                                if(segmask['rois'][i][3] < segmask['rois'][j][1]+((segmask['rois'][j][3]-segmask['rois'][j][1])/2)):
                                    entity_pairs.append([class_names[segmask['class_ids'][i]]+str(entity_number[i]), class_names[segmask['class_ids'][j]]+str(entity_number[j])])
                                    relations.append("is left to")
                                else: position=1;

                            if ((class_number[segmask['class_ids'][i]]) > 1 ):
                                class_number[segmask['class_ids'][i]]-= 1;
            
                        #Top left corner overlaps
                        if(segmask['rois'][i][0] > segmask['rois'][j][0] and segmask['rois'][i][0] < segmask['rois'][j][2]
                          and segmask['rois'][i][1] > segmask['rois'][j][1] and segmask['rois'][i][1] < segmask['rois'][j][3]):
                            if(segmask['rois'][i][0] > segmask['rois'][j][0]+((segmask['rois'][j][2]-segmask['rois'][j][0])/2)):
                                # _________
                                #|    |    |
                                #|----|----|
                                #|____|////|
                                if(segmask['rois'][i][1] > segmask['rois'][j][1]+((segmask['rois'][j][3]-segmask['rois'][j][1])/2)):
                                    entity_pairs.append([class_names[segmask['class_ids'][i]]+str(entity_number[i]), class_names[segmask['class_ids'][j]]+str(entity_number[j])])
                                    relations.append("is under right to")
                                # _________
                                #|         |
                                #|---------|
                                #|/////////|
                                else:
                                    entity_pairs.append([class_names[segmask['class_ids'][i]]+str(entity_number[i]), class_names[segmask['class_ids'][j]]+str(entity_number[j])])
                                    relations.append("is under")
                            else:
                                # _________
                                #|    |////|
                                #|    |////|
                                #|    |////|
                                if(segmask['rois'][i][1] > segmask['rois'][j][1]+((segmask['rois'][j][3]-segmask['rois'][j][1])/2)):
                                    entity_pairs.append([class_names[segmask['class_ids'][i]]+str(entity_number[i]), class_names[segmask['class_ids'][j]]+str(entity_number[j])])
                                    relations.append("is right to")
                                else: position=1;

                            if ((class_number[segmask['class_ids'][i]]) > 1 ):
                                class_number[segmask['class_ids'][i]]-= 1;

                        # _________
                        #|/////////|
                        #|/////////|
                        #|/////////|
                        if(position==1):
                            entity_pairs.append([class_names[segmask['class_ids'][i]]+str(entity_number[i]), class_names[segmask['class_ids'][j]]+str(entity_number[j])])
                            relations.append("is in front of or behind")
                            if ((class_number[segmask['class_ids'][i]]) > 1 ):
                                class_number[segmask['class_ids'][i]]-= 1;

            #print(entity_pairs)

            # extract subject
            source = [i[0] for i in entity_pairs]

            # extract object
            target = [i[1] for i in entity_pairs]

            results=[]
            for i in range(len(entity_pairs)):
                results.append([source[i], relations[i], target[i]])

            printGraph(results)
            i+=1

            ###################################
            def main():

              titre.title("Segmentation group")
  
              #Source afficher une vidéo: https://docs.streamlit.io/en/stable/api.html#display-media
              #Ne fonctionne pas (voir code dessus)

              #video_file = open('vidOK.mp4', 'rb').read()
              #st.video(video_bytes)
              graph.image("Graph.png")
              image2.image("frameimgwithboxes.jpg")
              image1.image("frameimg.jpg")
 
            if __name__ == '__main__':
	            main()
            ###########################################
        else: i+=1

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    else:
        break

capture.release()
output.release()
cv2.destroyAllWindows()


 

pip install ffmpeg

#Erreur quand import une video enregistrée par opencv

#https://discuss.streamlit.io/t/problem-with-displaying-a-recorded-video/3458
#ffmpeg -y -i vid.mp4 -vcodec libx264 vidOK.mp4


%%writefile app.py
import streamlit as st
import numpy as np
import pandas as pd
 
def main():
  st.title("Segmentation group")
  
  #Source afficher une vidéo: https://docs.streamlit.io/en/stable/api.html#display-media
  #Ne fonctionne pas (voir code dessus)
 
  #video_file = open('vidOK.mp4', 'rb').read()
  #st.video(video_bytes)
  st.image("Graph.png")
  st.image("frameimgwithboxes.jpg")
  st.image("frameimg.jpg")
  
if __name__ == '__main__':
	main()

!streamlit run --server.port 80 app.py &>/dev/null&

from pyngrok import ngrok
# Setup a tunnel to the streamlit port 8501
public_url = ngrok.connect(port='8501')
public_url

!ps -eaf | grep streamlit

ngrok.kill()
